# install.packages(c(
#   "tidyverse",
#   "rstudioapi"
#   "googledrive",
#   "googlesheets4",
#   "dotenv",
#   "leaflet",
#   "leafpop",
#   "leafem",
#   "mapview",
#   "remotes"
# ))

# remotes::install_github(c(
#   "rstudio/leaflet.mapboxgl",
#   "austensen/geoclient"
# ))

library(tidyverse)
library(rstudioapi)
library(googledrive)
library(googlesheets4)
library(geoclient)
library(dotenv)
library(leaflet)
library(leafpop)
library(leafem)
library(leaflet.mapboxgl)
library(mapview)


# Authorizations ----------------------------------------------------------

# Set API token for MapboxGL basemap. Sign up for free account at
# https://account.mapbox.com/auth/signup/
options(mapbox.accessToken = Sys.getenv("MAPBOX_TOKEN"))

# Set credentials keys for NYC's geocoding API. See "?geoclient_api_keys" for
# details on getting free account set up.
geoclient_api_keys(Sys.getenv("GEOCLIENT_ID"), Sys.getenv("GEOCLIENT_KEY"))

# Interactively authorize the {googlesheets4} and {googledrive} packages to
# access your Google account and then cache the authorization token for
# subsequent uses.
options(
  gargle_oauth_email = Sys.getenv("GOOGLE_EMAIL"),
  gargle_oauth_cache = ".cache"
)
sheets_auth()
drive_auth()


# Sheet Details -----------------------------------------------------------

# This sheet contains the responses from RTU's Google Form
sheet_url <- Sys.getenv("RTU_SHEET_URL")

# Simple column names for coding
# form_col_names <- c(
#   "timestamp", "email", "full_name", "pronouns", "cell_phone", "on_slack", "address",
#   "ok_group_chats", "volunteer_times", "has_car", "languages", "aid_types", "in_other_group",
#   "other_group_name", "other_comments", "has_bike", "safe_practices"
# )

# Shortened bilingual display column names for map
form_col_names <- c(
  "timestamp", "Email", "Name / Nombre", "Pronoun / Pronombre", 
  "Cell phone number / Número de teléfono", "On Slack?", "Address / Dirección", 
  "Group chats / Chats de grupo", "Times available / Horas disponible", "Car / Auto", 
  "Languages / Idiomas", "Aid / Ayuda", "Other group / Otro grupo",  "Group name / Llama el grupo", 
  "Comments / Comentarios", "Bike / Bicicleta", "Will adhere to safety practices"
)


# Geocoding ---------------------------------------------------------------

# There are many addresses that can't be geocoded with the API (or that are
# incorrectly identified, usually in the wrong borough), so these records are
# manually located and added to this file. Further down this script there is a
# point to check for new records that need to be added here.
manual_geocode_file <- "manual_geocode_results.csv"

if (file.exists(manual_geocode_file)) {
  manual_geocode_results <- manual_geocode_file %>% 
    read_csv(col_types = "i_dd") %>% 
    distinct(uid, .keep_all = TRUE)
} else {
  manual_geocode_results <- tibble(
    uid = integer(), 
    latitude = numeric(), 
    longitude = numeric()
  )
}

# Import the google sheet, skipping the header and providing the column names
# directly, and keeping everything as text data. The "timestamp" column is
# autogenerated, so if it is missing it's just extra rows at the bottom of the
# sheet. We also create a unique ID (row number) and rename address for coding
# convenience.
raw_data <- sheet_url %>% 
  read_sheet(col_names = form_col_names, col_types = "c", skip = 1) %>% 
  filter(!is.na(timestamp)) %>% 
  mutate(
    uid = row_number(),
    address = `Address / Dirección`
  )

# There are a lot of records without any address (mostly from early on, maybe
# before it was asked), and for now these are just dropped completely.
no_address <- raw_data %>% filter(is.na(address))

# After dropping records already manually geocoded or missing addresses, we do a
# first attempt to geocode the addresses using NYC's Geoclient API. The
# "geo_search_data" function returns a new dataframe with the results with the
# same length and in the same order as the input data, so we can just
# concatenate it to the input. Then we drop any records that couldn't be
# geocoded (no coordinates).
first_geocode <- raw_data %>% 
  anti_join(no_address, by = "uid") %>% 
  anti_join(manual_geocode_results, by = "uid") %>% 
  bind_cols(
    geo_search_data(., address) %>% select(latitude, longitude)
  ) %>% 
  filter(!is.na(latitude))

# Most of the addresses are in Queens (Ridgewood), so we add on the borough name
# to help out the geocoder and repeat the same process as before for the
# remaining records.
second_geocode <- raw_data %>% 
  anti_join(no_address, by = "uid") %>% 
  anti_join(manual_geocode_results, by = "uid") %>% 
  anti_join(first_geocode, by = "uid") %>% 
  mutate(address_boro = str_c(address, ", queens")) %>% 
  bind_cols(
    geo_search_data(., address_boro) %>% select(latitude, longitude)
  ) %>% 
  filter(!is.na(latitude))

# If there are still any records that have address that can't be geocoded using
# the API, we can look them up manually from this list and add the information
# to a the CSV file that's loaded at the top of this script.
to_manual_geocode <- raw_data %>%
  anti_join(no_address, by = "uid") %>%
  anti_join(manual_geocode_results, by = "uid") %>% 
  anti_join(first_geocode, by = "uid") %>%
  anti_join(second_geocode, by = "uid") %>% 
  select(uid, address)

if (nrow(to_manual_geocode) != 0) {
  to_manual_geocode %>% 
    add_column(latitude = "", longitude = "") %>% 
    write_csv(manual_geocode_file, append = file.exists(manual_geocode_file))
  
  navigateToFile(manual_geocode_file)
  
  stop(
    str_glue("There are {nrow(to_manual_geocode)} records to manually geocode!
             Please fill in the coordinates and re-run this geocoding section."), 
    call. = FALSE
  )
}


# Now that all the records are geocoded we can put the final dataset back
# together from all the parts, and tidy up the columns for display.
all_geocoded <- raw_data %>% 
  inner_join(manual_geocode_results, by = "uid") %>% 
  bind_rows(first_geocode, second_geocode) %>% 
  filter(!is.na(latitude)) %>% 
  mutate(`On Slack?` = recode(`On Slack?`, `FALSE` = "No", `TRUE` = "Yes")) %>% 
  mutate_if(is.character, replace_na, "-")


# Map ---------------------------------------------------------------------

# Select the columns to be displayed in the popup.
popup_cols <- c(
  # "uid", # for debugging/manual geocoding fixes
  "Name / Nombre", "Pronoun / Pronombre", "Address / Dirección", "Email", 
  "Cell phone number / Número de teléfono", "On Slack?", "Group chats / Chats de grupo", 
  "Times available / Horas disponible", "Aid / Ayuda", "Car / Auto", "Bike / Bicicleta", 
  "Languages / Idiomas", "Group name / Llama el grupo", "Comments / Comentarios", 
  "Will adhere to safety practices"
)

popup_options <- popupOptions()
popup_options[["maxHeight"]] <- 400

popup <- leafpop::popupTable(
  all_geocoded, 
  popup_cols, 
  row.numbers = FALSE, 
  feature.id = FALSE
)

rtu_map <- leaflet(all_geocoded) %>% 
  # TODO: We might want to edit the basemap to remove some unnecessary clutter
  addMapboxGL(style = "mapbox://styles/mapbox/streets-v9") %>% 
  addCircleMarkers(
    lng = ~longitude,
    lat = ~latitude,
    label = all_geocoded[["Name / Nombre"]],
    popup = popup,
    popupOptions = popup_options,
    fillColor = "red",
    fillOpacity = 1,
    stroke = FALSE,
    radius = 3
  ) %>% 
  addLogo(
    "img/rtu-logo.jpg",
    src = "local",
    position = "topright",
    width = 143,
    height = 60,
    offset.x = 20
  )

# Make sure to inspect the map each time and fix any geocoding errors. Often the
# error will be that it got the borough wrong, so the points will be noticeably
# outside the Ridgewood neighborhood. Uncomment the "uid" column above to add it
# to the popup table and then manually find the correct location and add it to
# the list at the top.
rtu_map

# Save the map locally as an HTML file.
mapshot(rtu_map, url = "RTU_mutual-aid-network-map.html")

# Upload the HTML file to Google Drive. This will create a new file if it's the
# first time, and update the file if it already exists, so the link won't change
# with each update.
drive_put("RTU_mutual-aid-network-map.html")
